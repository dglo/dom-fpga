TITLE "DCOM test signals and comm. thresholds, K.-H. Sulanke,DESY Zeuthen, 2006-03-21";
-- plus comm. and DAC level control tresholds
-- see tx_uart_ap.bdf, asymmetry (550ns) for first high pulse of every byte removed
-- TCAL test signals added
-- 032, see DCOM_tcal_timer.tdf, tcal_delay_ct introduced, DC_Rx_chan_01 instead of .._ap now
--      see dc_adc_diff_to_ser.tdf, RX_UART.bdf, comm. ADC input register,
-- 034, see see DC_adc_diff_to_ser.tdf, UA_RX02.dia,
-- 035, see dc_rapcal_lh.bdf, symmetric to the DOR rapcal_lh.bdf now
-- 036, see Tx_chan_ap, not_cfg_boot bit (sequence-number-bit12) added

CONSTANT DCFREV			= 036;	-- DOM Communication module revision (dec.)

CONSTANT COM_THRESH		=  80;	-- accumulated (4 clocks) HL-edge height after substracting the baseline
CONSTANT REC_DELAY		=  10;	-- x 50ns, receiver start up delay to deal with signal reflections from last send
-- you may add cable_length(m)/5
CONSTANT SEND_DELAY		= 255;	-- x 50ns, send delay to deal with signal reflections

CONSTANT DAC_MAX_LEVEL	= 255;	-- comm. DAC max. level

CONSTANT MIN_CLEV		= 960;	-- needed for comm. DAC level adaption
CONSTANT MAX_CLEV		= 970;	-- needed for comm. DAC level adaption

SUBDESIGN test_and_tresholds
(
--	stf_stb			: INPUT;
--	data_stb		: INPUT;
--	eof_stb			: INPUT;
comres_rcvd		: INPUT;	
--	lh_edge			: INPUT;
--	data_error		: INPUT;
--	ctrl_msg		: INPUT;
--	data_msg		: INPUT;	
--	crc_zero		: INPUT;
--	rx_addr[1..0]	: INPUT;
--	tx_dataout[15..12]	: INPUT;
--	rx_we			: INPUT;
--	drreq_rcvd		: INPUT;
--	tx_empty		: INPUT;
--	tx_alm_empty	: INPUT;	
--	tx_pack_sent	: INPUT;
--	tx_dpr_ren		: INPUT;
--	send_data		: INPUT;
--	tx_pack_rdy		: INPUT;

tx_data[7..0]	: INPUT;
data_val		: INPUT;
ctrl_val		: INPUT;

rec_ena			: INPUT;
COMM_RESET		: INPUT;
com_avail		: INPUT;
DC_CTRAP_res	: INPUT;
stf_stb			: INPUT;
eof_stb			: INPUT;

CLK20			: INPUT;
reboot_now		: INPUT;
sysres_rcvd		: INPUT;
idle_rcvd		: INPUT;	
--	reboot_gnt		: INPUT;
--	com_avail		: INPUT;
buf_res			: INPUT;	-- from DC_CTRAP, one clock length pulse after RST
--	data_error		: INPUT;
--	ctrl_error		: INPUT;
tcal_rcvd		: INPUT;
hl_edge			: INPUT;
--	edge_end		: INPUT;
pulse_rcvd		: INPUT;
pulse_sent		: INPUT;
--	del_15us		: INPUT;
--	del_30us		: INPUT;	-- VDOM debug

com_thr_d[7..0]	: INPUT;	-- HL-edge length after 6 clocks
dac_max_d[6..5]	: INPUT;
rec_del_d[7..0]	: INPUT;
send_del_d[7..0]: INPUT;

clev_min_d[9..0]: INPUT;	-- needed for comm. DAC level adaption
clev_max_d[9..0]: INPUT;	-- needed for comm. DAC level adaption

thr_del_wr		: INPUT;	-- write strobe, at least one clock length
clev_wr			: INPUT;	-- write strobe, at least one clock length

com_thr[7..0]	: OUTPUT;	-- HL-edge length after 6 clocks
dac_max[7..0]	: OUTPUT;	
rec_del[7..0]	: OUTPUT;
send_del[7..0]	: OUTPUT;

clev_min[9..0]	: OUTPUT;	-- needed for comm. DAC level adaption
clev_max[9..0]	: OUTPUT;	-- needed for comm. DAC level adaption

rev[15..0]		: OUTPUT;	-- DOM comm. module revision
tc[7..0]		: OUTPUT;	-- DOM test connector
)

VARIABLE

com_thr[7..0]		: DFFE;
dac_max[7..0]		: DFFE;
rec_del[7..0]		: DFFE;
send_del[7..0]		: DFFE;

clev_min[9..0]		: DFFE;
clev_max[9..0]		: DFFE;


BEGIN

rev[]	= DCFREV;

--tc[6..0] = tx_data[6..0];
IF tx_data > 126 THEN tc[6..0]=126; ELSE tc[6..0] = tx_data[6..0]; END IF;
tc[7] = data_val; -- or ctrl_val;

--tc[0]	= rec_ena;
--tc[1]	= COMM_RESET;
--tc[2]	= sysres_rcvd;
--tc[3]	= com_avail;
--tc[4]	= DC_CTRAP_res;
--tc[5]	= hl_edge;
--tc[6]	= stf_stb;
--tc[7]	= eof_stb;


--	tc[0]	= tcal_rcvd;	--reboot_req;
--	tc[1]	= sysres_rcvd;
--	tc[2]	= idle_rcvd;
--	tc[3]	= hl_edge;		--edge_end;		--ctrl_error;
--	
--	tc[4]	= buf_res; --pulse_rcvd;	--buf_res;
--	tc[5]	= pulse_sent;
--	tc[6]	= comres_rcvd;
--	tc[7]	= reboot_now;
--	tc[0]	= ;
--	tc[1]	= drreq_rcvd;
--	tc[2]	= data_msg;
--	tc[3]	= send_data;
--	tc[4]	= tx_empty;
--	tc[5]	= buf_res;
--	tc[6]	= ctrl_error;
--	tc[7]	= data_error;

-- CTHR, write only, temporarily ???
-- use thr_del_wr

com_thr[].clk		= CLK20;
com_thr[].ena		= thr_del_wr;
com_thr[].d			= com_thr_d[];

if(buf_res)	THEN	com_thr[].prn = !COM_THRESH;
ELSE				com_thr[].prn = vcc;			END IF;

dac_max[4..0].clk	= CLK20;
dac_max[4..0].ena	= vcc;
dac_max[4..0].d		= vcc;
dac_max[7].clk		= CLK20;
dac_max[7].ena		= vcc;
dac_max[7].d		= vcc;

dac_max[6..5].clk	= CLK20;
dac_max[6..5].ena	= thr_del_wr;
dac_max[6..5].d		= dac_max_d[6..5];

if(buf_res)	THEN	dac_max[].prn = !DAC_MAX_LEVEL;
ELSE				dac_max[].prn = vcc;			END IF;

rec_del[].clk		= CLK20;
rec_del[].ena		= thr_del_wr;
rec_del[].d			= rec_del_d[];

if(buf_res)	THEN	rec_del[].prn = !REC_DELAY;
ELSE				rec_del[].prn = vcc;			END IF;

send_del[].clk		= CLK20;
send_del[].ena		= thr_del_wr;
send_del[].d		= send_del_d[];

if(buf_res)	THEN	send_del[].prn = !SEND_DELAY;
ELSE				send_del[].prn = vcc;			END IF;


-- CLEV_MIN, CLEV_MAX, write only (temporarily ?)
-- use clev_wr

clev_min[].clk		= CLK20;
clev_min[].ena		= clev_wr;
clev_min[].d		= clev_min_d[];

if(buf_res)	THEN	clev_min[].prn = !MIN_CLEV;
ELSE				clev_min[].prn = vcc;			END IF;

clev_max[].clk		= CLK20;
clev_max[].ena		= clev_wr;
clev_max[].d		= clev_max_d[];

if(buf_res)	THEN	clev_max[].prn = !MAX_CLEV;
ELSE				clev_max[].prn = vcc;			END IF;


END;
