TITLE "ADC to serial decoder, LAST CHANGE: 2004-06-22";

INCLUDE "hl_dscr";
INCLUDE "ctup4b";

--FUNCTION HL_DSCR (CLK, ct0, ct1, ct2, ct3, hl_edge, one_lev, res)
--	RETURNS (ct_aclr, maxen, minen, one);

--FUNCTION ctup4b (clock, aclr)
--RETURNS (	q[3..0]);


SUBDESIGN	adc_to_ser
(
	clk					: INPUT;
	reset				: INPUT;
	in[9..0]			: INPUT;	-- Communication ADC, meanvalue over 4 clocks
	low_thr[9..0]		: INPUT;	-- Communication threshold, long cable 
	lrg_thr[9..0]		: INPUT;	-- Communication threshold, short cable 
		
	hl_edge				: OUTPUT;
	rxd					: OUTPUT;	-- serial data, 1 clock lengths pulse if ==1
)


VARIABLE

	ina[9..0]		: DFF;		-- I/O register
	inb[9..0]		: DFF;

	max_val[9..0]	: DFFE;
	
	hl_edge			: DFF;
	one_lev			: DFF;
		
	ct				: ctup4b;	-- 3 bit up counter
	hl_dec_stm		: hl_dscr;	-- state machine
	
BEGIN

hl_dec_stm.(CLK, ct0, ct1, ct2, ct3, hl_edge, one_lev, res)
	= (clk, ct.q0, ct.q1, ct.q2, ct.q3, hl_edge.q, one_lev.q, reset);


	ct.clock				= clk;
	ct.aclr					= hl_dec_stm.ct_aclr;

	ina[].clk				= clk;
	inb[].clk				= clk;

	ina[].d					= in[];
	inb[].d					= ina[].q;

	max_val[].clk			= clk;
	max_val[].d				= ina[].q;
	max_val[].ena			= hl_dec_stm.maxen;

	
	hl_edge.(clk,clrn)		= (clk, !reset);

	if( (0,inb[9..0]) > (0,ina[9..0])+(0,low_thr[9..0]))	-- difference between consecutive samples
		THEN	hl_edge.d	= VCC;	
		else	hl_edge.d	= GND;		END IF;		-- avoid negative numbers
													-- when comparing !!!
	one_lev.(clk,clrn)		= (clk, !reset);
				
	if( (0,max_val[9..0])	> (0,ina[9..0]) + (0,lrg_thr[9..0]))
		THEN	one_lev.d	= VCC;	
		else	one_lev.d	= GND;		END IF;	

	rxd			= hl_dec_stm.one;
	
END;
