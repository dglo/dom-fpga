TITLE "ADC to serial decoder, LAST CHANGE: 2004-07-15";

INCLUDE "hl_dscr";
INCLUDE "ctup4b";

--CONSTANT COMADC_MAX = 1000;
--CONSTANT COMADC_MIN = 950;

--FUNCTION HL_DSCR (CLK, ct0, ct1, ct2, ct3, low_hl, low_lev, lrg_hl, lrg_lev, uart_done, res)
--	RETURNS (lowsig, lrgsig, one_lev, ct_aclr, maxen, hl_edge, one);


--FUNCTION ctup4b (clock, aclr)
--RETURNS (	q[3..0]);


SUBDESIGN	dc_adc_to_ser
(
	clk					: INPUT;
	reset				: INPUT;
	in[9..0]			: INPUT;	-- Communication ADC, meanvalue over 4 clocks
	low_thr[7..0]		: INPUT;	-- Communication threshold, long cable 
	lrg_thr[9..0]		: INPUT;	-- Communication threshold, short cable
	low_stp[3..0]		: INPUT;	-- Communication threshold, between consecutive samples, long cable 
	lrg_stp[7..0]		: INPUT;	-- Communication threshold, between consecutive samples,  short cable
	uart_done			: INPUT;	-- Rx UART ready
	seq0_byte			: INPUT;
	data_stb			: INPUT;
	my_adr				: INPUT;
	clev_min[9..0]		: INPUT;
	clev_max[9..0]		: INPUT;
	COM_AD_D[9..0]		: INPUT;
		
	hl_edge				: OUTPUT;
	rxd					: OUTPUT;	-- serial data, 1 clock lengths pulse if ==1
	big_signal			: OUTPUT;
	small_signal		: OUTPUT;
	dorlev_up_rq		: OUTPUT;	-- DOM comm. DAC level control
	dorlev_dn_rq		: OUTPUT;
	one_lev				: OUTPUT;	-- needed for TCAL
)


VARIABLE

	ina[9..0]		: DFF;		-- I/O register
	inb[9..0]		: DFF;

	max_val[9..0]	: DFFE;
	low_hl			: DFF;
	low_lev			: DFF;
	lrg_hl			: DFF;
	lrg_lev			: DFF;
	
	hl_edge			: DFF;

	ct				: ctup4b;	-- 3 bit up counter
	hl_dec_stm		: hl_dscr;	-- state machine
	
	dorlev_up_rq	: DFFE;	-- DOM comm. DAC level control
	dorlev_dn_rq	: DFFE;
	
	adcmax[9..0]	: DFFE;
	
BEGIN

	ct.clock				= clk;
	ct.aclr					= hl_dec_stm.ct_aclr;

	ina[].clk				= clk;
	inb[].clk				= clk;

	ina[].d					= in[];
	inb[].d					= ina[].q;

	max_val[].clk			= clk;
	max_val[].d				= ina[].q;
	max_val[].ena			= hl_dec_stm.maxen;

	
	low_hl.(clk,clrn)		= (clk, !reset);
	
	if( (0,inb[9..0]) > (0,ina[9..0])+(0,low_stp[3..0]))	-- difference between consecutive samples
		THEN	low_hl.d	= VCC;	
		else	low_hl.d	= GND;		END IF;				-- avoid negative numbers
															-- when comparing !!!
	lrg_hl.(clk,clrn)		= (clk, !reset);

	if( (0,inb[9..0]) > (0,ina[9..0])+(0,lrg_stp[7..0]))	-- difference between consecutive samples
		THEN	lrg_hl.d	= VCC;	
		else	lrg_hl.d	= GND;		END IF;	
													
	low_lev.(clk,clrn)		= (clk, !reset);
				
	if( (0,max_val[9..0])	> (0,ina[9..0]) + (0,low_thr[7..0]))
		THEN	low_lev.d	= VCC;	
		else	low_lev.d	= GND;		END IF;	

	lrg_lev.(clk,clrn)		= (clk, !reset);
				
	if( (0,max_val[9..0])	> (0,ina[9..0]) + (0,lrg_thr[9..0]))
		THEN	lrg_lev.d	= VCC;	
		else	lrg_lev.d	= GND;		END IF;	
		
hl_dec_stm.(CLK, ct0, ct1, ct2, ct3,    low_hl,   low_lev,   lrg_hl,   lrg_lev,   uart_done, res)
	= (clk, ct.q0, ct.q1, ct.q2, ct.q3, low_hl.q, low_lev.q, lrg_hl.q, lrg_lev.q, uart_done, reset);

	hl_edge.(clk,clrn)		= (clk, !reset);
	hl_edge.d				= hl_dec_stm.hl_edge;
	rxd						= hl_dec_stm.one;
	
	big_signal				= hl_dec_stm.lrgsig;
	small_signal			= hl_dec_stm.lowsig;
	
	adcmax[].clk			= clk;
	adcmax[].clrn			= !uart_done;
	adcmax[].d				= ina[].q;	--COM_AD_D[9..0];	--

	if((adcmax[].q < ina[].q))		THEN	adcmax[].ena	= VCC;	END IF;
	
	dorlev_up_rq.(clk, clrn)	= (clk, VCC);
	dorlev_dn_rq.(clk, clrn)	= (clk, VCC);

	dorlev_up_rq.(d,ena)		= (adcmax[].q < clev_min[], seq0_byte & data_stb & my_adr);
	dorlev_dn_rq.(d,ena)		= (adcmax[].q > clev_max[], seq0_byte & data_stb & my_adr);
	
	one_lev					= hl_dec_stm.one_lev;
END;
